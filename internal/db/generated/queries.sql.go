// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	db "github.com/arne314/inbox-collab/internal/db/sqlc"
	"github.com/jackc/pgx/v5/pgtype"
)

const addFetcher = `-- name: AddFetcher :exec
INSERT INTO fetcher (id)
VALUES ($1)
`

func (q *Queries) AddFetcher(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, addFetcher, id)
	return err
}

const addMail = `-- name: AddMail :many
INSERT INTO mail (fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (header_id) DO NOTHING
RETURNING id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id
`

type AddMailParams struct {
	Fetcher          pgtype.Text
	HeaderID         string
	HeaderInReplyTo  string
	HeaderReferences []string
	Timestamp        pgtype.Timestamp
	NameFrom         string
	AddrFrom         string
	AddrTo           []string
	Subject          string
	Body             *string
	Attachments      []string
}

func (q *Queries) AddMail(ctx context.Context, arg AddMailParams) ([]*Mail, error) {
	rows, err := q.db.Query(ctx, addMail,
		arg.Fetcher,
		arg.HeaderID,
		arg.HeaderInReplyTo,
		arg.HeaderReferences,
		arg.Timestamp,
		arg.NameFrom,
		arg.AddrFrom,
		arg.AddrTo,
		arg.Subject,
		arg.Body,
		arg.Attachments,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addRoom = `-- name: AddRoom :exec
INSERT INTO room (id)
VALUES ($1)
ON CONFLICT (id) DO NOTHING
`

func (q *Queries) AddRoom(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, addRoom, id)
	return err
}

const addThread = `-- name: AddThread :one
INSERT INTO thread (last_message, first_mail, last_mail)
VALUES (CURRENT_TIMESTAMP, $1, $1)
RETURNING id, enabled, force_close, last_message, matrix_id, matrix_room_id, first_mail, last_mail
`

func (q *Queries) AddThread(ctx context.Context, firstMail pgtype.Int8) (*Thread, error) {
	row := q.db.QueryRow(ctx, addThread, firstMail)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.ForceClose,
		&i.LastMessage,
		&i.MatrixID,
		&i.MatrixRoomID,
		&i.FirstMail,
		&i.LastMail,
	)
	return &i, err
}

const autoUpdateMailReplyTo = `-- name: AutoUpdateMailReplyTo :execrows
UPDATE mail
SET reply_to = m.id
FROM mail m
WHERE mail.thread IS NULL AND mail.header_in_reply_to = m.header_id
`

func (q *Queries) AutoUpdateMailReplyTo(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, autoUpdateMailReplyTo)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getFetcherState = `-- name: GetFetcherState :many
SELECT id, uid_last, uid_validity FROM fetcher
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFetcherState(ctx context.Context, id string) ([]*Fetcher, error) {
	rows, err := q.db.Query(ctx, getFetcherState, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Fetcher
	for rows.Next() {
		var i Fetcher
		if err := rows.Scan(&i.ID, &i.UidLast, &i.UidValidity); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMail = `-- name: GetMail :one
SELECT mail.id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, mail.matrix_id, thread.id, enabled, force_close, last_message, thread.matrix_id, matrix_room_id, first_mail, last_mail FROM mail
LEFT JOIN thread ON thread.id = mail.thread
WHERE mail.id = $1 LIMIT 1
`

type GetMailRow struct {
	ID                 int64
	Fetcher            pgtype.Text
	HeaderID           string
	HeaderInReplyTo    string
	HeaderReferences   []string
	Timestamp          pgtype.Timestamp
	NameFrom           string
	AddrFrom           string
	AddrTo             []string
	Subject            string
	Body               *string
	Attachments        []string
	Messages           *db.ExtractedMessages
	MessagesLastUpdate pgtype.Timestamp
	Sorted             bool
	ReplyTo            pgtype.Int8
	Thread             pgtype.Int8
	MatrixID           pgtype.Text
	ID_2               pgtype.Int8
	Enabled            pgtype.Bool
	ForceClose         pgtype.Bool
	LastMessage        pgtype.Timestamp
	MatrixID_2         pgtype.Text
	MatrixRoomID       pgtype.Text
	FirstMail          pgtype.Int8
	LastMail           pgtype.Int8
}

func (q *Queries) GetMail(ctx context.Context, id int64) (*GetMailRow, error) {
	row := q.db.QueryRow(ctx, getMail, id)
	var i GetMailRow
	err := row.Scan(
		&i.ID,
		&i.Fetcher,
		&i.HeaderID,
		&i.HeaderInReplyTo,
		&i.HeaderReferences,
		&i.Timestamp,
		&i.NameFrom,
		&i.AddrFrom,
		&i.AddrTo,
		&i.Subject,
		&i.Body,
		&i.Attachments,
		&i.Messages,
		&i.MessagesLastUpdate,
		&i.Sorted,
		&i.ReplyTo,
		&i.Thread,
		&i.MatrixID,
		&i.ID_2,
		&i.Enabled,
		&i.ForceClose,
		&i.LastMessage,
		&i.MatrixID_2,
		&i.MatrixRoomID,
		&i.FirstMail,
		&i.LastMail,
	)
	return &i, err
}

const getMailByMatrixId = `-- name: GetMailByMatrixId :one
SELECT id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id FROM mail
WHERE matrix_id = $1 LIMIT 1
`

func (q *Queries) GetMailByMatrixId(ctx context.Context, matrixID pgtype.Text) (*Mail, error) {
	row := q.db.QueryRow(ctx, getMailByMatrixId, matrixID)
	var i Mail
	err := row.Scan(
		&i.ID,
		&i.Fetcher,
		&i.HeaderID,
		&i.HeaderInReplyTo,
		&i.HeaderReferences,
		&i.Timestamp,
		&i.NameFrom,
		&i.AddrFrom,
		&i.AddrTo,
		&i.Subject,
		&i.Body,
		&i.Attachments,
		&i.Messages,
		&i.MessagesLastUpdate,
		&i.Sorted,
		&i.ReplyTo,
		&i.Thread,
		&i.MatrixID,
	)
	return &i, err
}

const getMailsByMessageIds = `-- name: GetMailsByMessageIds :many
SELECT id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id FROM mail
WHERE header_id = ANY($1::text[])
ORDER BY timestamp
`

func (q *Queries) GetMailsByMessageIds(ctx context.Context, dollar_1 []string) ([]*Mail, error) {
	rows, err := q.db.Query(ctx, getMailsByMessageIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailsByThread = `-- name: GetMailsByThread :many
SELECT id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id FROM mail
WHERE thread = $1
ORDER BY timestamp
`

func (q *Queries) GetMailsByThread(ctx context.Context, thread pgtype.Int8) ([]*Mail, error) {
	rows, err := q.db.Query(ctx, getMailsByThread, thread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailsRequiringMessageExtraction = `-- name: GetMailsRequiringMessageExtraction :many
SELECT id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id FROM mail
WHERE sorted AND fetcher IS NOT NULL AND messages ->> 'messages' IS NULL
ORDER BY thread, timestamp
`

func (q *Queries) GetMailsRequiringMessageExtraction(ctx context.Context) ([]*Mail, error) {
	rows, err := q.db.Query(ctx, getMailsRequiringMessageExtraction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailsRequiringSorting = `-- name: GetMailsRequiringSorting :many
SELECT id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, matrix_id FROM mail
WHERE NOT sorted
ORDER BY timestamp
`

func (q *Queries) GetMailsRequiringSorting(ctx context.Context) ([]*Mail, error) {
	rows, err := q.db.Query(ctx, getMailsRequiringSorting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatrixReadyMails = `-- name: GetMatrixReadyMails :many
SELECT mail.id, mail.fetcher, mail.header_id, mail.header_in_reply_to, mail.header_references, mail.timestamp, mail.name_from, mail.addr_from, mail.addr_to, mail.subject, mail.body, mail.attachments, mail.messages, mail.messages_last_update, mail.sorted, mail.reply_to, mail.thread, mail.matrix_id,
thread.matrix_id AS root_matrix_id, thread.matrix_room_id AS root_matrix_room_id, mail.id = thread.first_mail AS is_first
FROM mail
JOIN thread ON mail.thread = thread.id
WHERE mail.matrix_id IS NULL AND thread.matrix_id IS NOT NULL
AND mail.messages ->> 'messages' IS NOT NULL
ORDER BY mail.timestamp
`

type GetMatrixReadyMailsRow struct {
	ID                 int64
	Fetcher            pgtype.Text
	HeaderID           string
	HeaderInReplyTo    string
	HeaderReferences   []string
	Timestamp          pgtype.Timestamp
	NameFrom           string
	AddrFrom           string
	AddrTo             []string
	Subject            string
	Body               *string
	Attachments        []string
	Messages           *db.ExtractedMessages
	MessagesLastUpdate pgtype.Timestamp
	Sorted             bool
	ReplyTo            pgtype.Int8
	Thread             pgtype.Int8
	MatrixID           pgtype.Text
	RootMatrixID       pgtype.Text
	RootMatrixRoomID   pgtype.Text
	IsFirst            bool
}

func (q *Queries) GetMatrixReadyMails(ctx context.Context) ([]*GetMatrixReadyMailsRow, error) {
	rows, err := q.db.Query(ctx, getMatrixReadyMails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMatrixReadyMailsRow
	for rows.Next() {
		var i GetMatrixReadyMailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
			&i.RootMatrixID,
			&i.RootMatrixRoomID,
			&i.IsFirst,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatrixReadyThreads = `-- name: GetMatrixReadyThreads :many
SELECT thread.id, thread.matrix_room_id, mail.fetcher,
mail.addr_from, mail.addr_to, mail.subject, mail.name_from FROM thread
JOIN mail ON thread.first_mail = mail.id
WHERE thread.matrix_id IS NULL
AND mail.messages ->> 'messages' IS NOT NULL
ORDER BY mail.timestamp
`

type GetMatrixReadyThreadsRow struct {
	ID           int64
	MatrixRoomID pgtype.Text
	Fetcher      pgtype.Text
	AddrFrom     string
	AddrTo       []string
	Subject      string
	NameFrom     string
}

func (q *Queries) GetMatrixReadyThreads(ctx context.Context) ([]*GetMatrixReadyThreadsRow, error) {
	rows, err := q.db.Query(ctx, getMatrixReadyThreads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMatrixReadyThreadsRow
	for rows.Next() {
		var i GetMatrixReadyThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.MatrixRoomID,
			&i.Fetcher,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.NameFrom,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverviewThreads = `-- name: GetOverviewThreads :many
SELECT thread.id, thread.enabled, thread.force_close, thread.last_message, thread.matrix_id, thread.matrix_room_id, thread.first_mail, thread.last_mail, mail.name_from, mail.addr_from, mail.subject, mail.matrix_id AS message_id
FROM thread
JOIN mail ON mail.id = thread.first_mail
WHERE thread.enabled AND thread.matrix_room_id = ANY($1::text[]) AND thread.matrix_id IS NOT NULL
ORDER BY thread.last_message DESC
`

type GetOverviewThreadsRow struct {
	ID           int64
	Enabled      bool
	ForceClose   pgtype.Bool
	LastMessage  pgtype.Timestamp
	MatrixID     pgtype.Text
	MatrixRoomID pgtype.Text
	FirstMail    pgtype.Int8
	LastMail     pgtype.Int8
	NameFrom     string
	AddrFrom     string
	Subject      string
	MessageID    pgtype.Text
}

func (q *Queries) GetOverviewThreads(ctx context.Context, dollar_1 []string) ([]*GetOverviewThreadsRow, error) {
	rows, err := q.db.Query(ctx, getOverviewThreads, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOverviewThreadsRow
	for rows.Next() {
		var i GetOverviewThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Enabled,
			&i.ForceClose,
			&i.LastMessage,
			&i.MatrixID,
			&i.MatrixRoomID,
			&i.FirstMail,
			&i.LastMail,
			&i.NameFrom,
			&i.AddrFrom,
			&i.Subject,
			&i.MessageID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReferencedThreadParent = `-- name: GetReferencedThreadParent :many
SELECT mail.id, fetcher, header_id, header_in_reply_to, header_references, timestamp, name_from, addr_from, addr_to, subject, body, attachments, messages, messages_last_update, sorted, reply_to, thread, mail.matrix_id, thread.id, enabled, force_close, last_message, thread.matrix_id, matrix_room_id, first_mail, last_mail FROM mail
JOIN thread ON thread.id = mail.thread
WHERE header_id = ANY($1::text[]) AND NOT thread.force_close
ORDER BY timestamp DESC
LIMIT 1
`

type GetReferencedThreadParentRow struct {
	ID                 int64
	Fetcher            pgtype.Text
	HeaderID           string
	HeaderInReplyTo    string
	HeaderReferences   []string
	Timestamp          pgtype.Timestamp
	NameFrom           string
	AddrFrom           string
	AddrTo             []string
	Subject            string
	Body               *string
	Attachments        []string
	Messages           *db.ExtractedMessages
	MessagesLastUpdate pgtype.Timestamp
	Sorted             bool
	ReplyTo            pgtype.Int8
	Thread             pgtype.Int8
	MatrixID           pgtype.Text
	ID_2               int64
	Enabled            bool
	ForceClose         pgtype.Bool
	LastMessage        pgtype.Timestamp
	MatrixID_2         pgtype.Text
	MatrixRoomID       pgtype.Text
	FirstMail          pgtype.Int8
	LastMail           pgtype.Int8
}

func (q *Queries) GetReferencedThreadParent(ctx context.Context, dollar_1 []string) ([]*GetReferencedThreadParentRow, error) {
	rows, err := q.db.Query(ctx, getReferencedThreadParent, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReferencedThreadParentRow
	for rows.Next() {
		var i GetReferencedThreadParentRow
		if err := rows.Scan(
			&i.ID,
			&i.Fetcher,
			&i.HeaderID,
			&i.HeaderInReplyTo,
			&i.HeaderReferences,
			&i.Timestamp,
			&i.NameFrom,
			&i.AddrFrom,
			&i.AddrTo,
			&i.Subject,
			&i.Body,
			&i.Attachments,
			&i.Messages,
			&i.MessagesLastUpdate,
			&i.Sorted,
			&i.ReplyTo,
			&i.Thread,
			&i.MatrixID,
			&i.ID_2,
			&i.Enabled,
			&i.ForceClose,
			&i.LastMessage,
			&i.MatrixID_2,
			&i.MatrixRoomID,
			&i.FirstMail,
			&i.LastMail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoom = `-- name: GetRoom :one
SELECT id, name, name_last_update, overview_message_id, overview_message_last_update FROM room
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRoom(ctx context.Context, id string) (*Room, error) {
	row := q.db.QueryRow(ctx, getRoom, id)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NameLastUpdate,
		&i.OverviewMessageID,
		&i.OverviewMessageLastUpdate,
	)
	return &i, err
}

const getRooms = `-- name: GetRooms :many
SELECT id, name, name_last_update, overview_message_id, overview_message_last_update FROM room
WHERE id = ANY($1::text[])
`

func (q *Queries) GetRooms(ctx context.Context, dollar_1 []string) ([]*Room, error) {
	rows, err := q.db.Query(ctx, getRooms, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NameLastUpdate,
			&i.OverviewMessageID,
			&i.OverviewMessageLastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadByMatrixId = `-- name: GetThreadByMatrixId :one
SELECT id, enabled, force_close, last_message, matrix_id, matrix_room_id, first_mail, last_mail FROM thread
WHERE matrix_id = $1 LIMIT 1
`

func (q *Queries) GetThreadByMatrixId(ctx context.Context, matrixID pgtype.Text) (*Thread, error) {
	row := q.db.QueryRow(ctx, getThreadByMatrixId, matrixID)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.ForceClose,
		&i.LastMessage,
		&i.MatrixID,
		&i.MatrixRoomID,
		&i.FirstMail,
		&i.LastMail,
	)
	return &i, err
}

const mailCount = `-- name: MailCount :one
SELECT COUNT(*) FROM mail
`

func (q *Queries) MailCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, mailCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeMailMatrixIdsByThread = `-- name: RemoveMailMatrixIdsByThread :exec
UPDATE mail
SET matrix_id = NULL
WHERE thread = $1
`

func (q *Queries) RemoveMailMatrixIdsByThread(ctx context.Context, thread pgtype.Int8) error {
	_, err := q.db.Exec(ctx, removeMailMatrixIdsByThread, thread)
	return err
}

const removeThreadMatrixId = `-- name: RemoveThreadMatrixId :exec
UPDATE thread
SET matrix_id = NULL
WHERE id = $1
`

func (q *Queries) RemoveThreadMatrixId(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, removeThreadMatrixId, id)
	return err
}

const updateExtractedMessages = `-- name: UpdateExtractedMessages :exec
UPDATE mail
SET messages = $2, messages_last_update = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateExtractedMessagesParams struct {
	ID       int64
	Messages *db.ExtractedMessages
}

func (q *Queries) UpdateExtractedMessages(ctx context.Context, arg UpdateExtractedMessagesParams) error {
	_, err := q.db.Exec(ctx, updateExtractedMessages, arg.ID, arg.Messages)
	return err
}

const updateFetcherState = `-- name: UpdateFetcherState :exec
UPDATE fetcher
SET uid_last = $2, uid_validity = $3
WHERE id = $1
`

type UpdateFetcherStateParams struct {
	ID          string
	UidLast     int32
	UidValidity int32
}

func (q *Queries) UpdateFetcherState(ctx context.Context, arg UpdateFetcherStateParams) error {
	_, err := q.db.Exec(ctx, updateFetcherState, arg.ID, arg.UidLast, arg.UidValidity)
	return err
}

const updateMailMarkSorted = `-- name: UpdateMailMarkSorted :exec
UPDATE mail
SET sorted = TRUE
WHERE id = $1
`

func (q *Queries) UpdateMailMarkSorted(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateMailMarkSorted, id)
	return err
}

const updateMailMatrixId = `-- name: UpdateMailMatrixId :exec
UPDATE mail
SET matrix_id = $2
WHERE id = $1
`

type UpdateMailMatrixIdParams struct {
	ID       int64
	MatrixID pgtype.Text
}

func (q *Queries) UpdateMailMatrixId(ctx context.Context, arg UpdateMailMatrixIdParams) error {
	_, err := q.db.Exec(ctx, updateMailMatrixId, arg.ID, arg.MatrixID)
	return err
}

const updateMailSorting = `-- name: UpdateMailSorting :exec
UPDATE mail
SET reply_to = $3, thread = $2, sorted = TRUE
WHERE id = $1
`

type UpdateMailSortingParams struct {
	ID      int64
	Thread  pgtype.Int8
	ReplyTo pgtype.Int8
}

func (q *Queries) UpdateMailSorting(ctx context.Context, arg UpdateMailSortingParams) error {
	_, err := q.db.Exec(ctx, updateMailSorting, arg.ID, arg.Thread, arg.ReplyTo)
	return err
}

const updateRoomName = `-- name: UpdateRoomName :exec
UPDATE room
SET name = $2, name_last_update = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateRoomNameParams struct {
	ID   string
	Name pgtype.Text
}

func (q *Queries) UpdateRoomName(ctx context.Context, arg UpdateRoomNameParams) error {
	_, err := q.db.Exec(ctx, updateRoomName, arg.ID, arg.Name)
	return err
}

const updateRoomOverviewMessage = `-- name: UpdateRoomOverviewMessage :exec
UPDATE room
SET overview_message_id = $2, overview_message_last_update = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateRoomOverviewMessageParams struct {
	ID                string
	OverviewMessageID pgtype.Text
}

func (q *Queries) UpdateRoomOverviewMessage(ctx context.Context, arg UpdateRoomOverviewMessageParams) error {
	_, err := q.db.Exec(ctx, updateRoomOverviewMessage, arg.ID, arg.OverviewMessageID)
	return err
}

const updateThreadEnabled = `-- name: UpdateThreadEnabled :execrows
UPDATE thread
SET enabled = $3, force_close = COALESCE($4, force_close)
WHERE matrix_id = $1 AND matrix_room_id = $2 AND (enabled != $3 OR force_close != COALESCE($4, force_close))
`

type UpdateThreadEnabledParams struct {
	MatrixID     pgtype.Text
	MatrixRoomID pgtype.Text
	Enabled      bool
	ForceClose   pgtype.Bool
}

func (q *Queries) UpdateThreadEnabled(ctx context.Context, arg UpdateThreadEnabledParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateThreadEnabled,
		arg.MatrixID,
		arg.MatrixRoomID,
		arg.Enabled,
		arg.ForceClose,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateThreadLastMail = `-- name: UpdateThreadLastMail :exec
UPDATE thread
SET enabled = TRUE, last_message = GREATEST(last_message, $3), last_mail = $2
WHERE id = $1
`

type UpdateThreadLastMailParams struct {
	ID          int64
	LastMail    pgtype.Int8
	LastMessage pgtype.Timestamp
}

func (q *Queries) UpdateThreadLastMail(ctx context.Context, arg UpdateThreadLastMailParams) error {
	_, err := q.db.Exec(ctx, updateThreadLastMail, arg.ID, arg.LastMail, arg.LastMessage)
	return err
}

const updateThreadLastMessage = `-- name: UpdateThreadLastMessage :exec
UPDATE thread
SET last_message = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdateThreadLastMessage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateThreadLastMessage, id)
	return err
}

const updateThreadMatrixIds = `-- name: UpdateThreadMatrixIds :exec
UPDATE thread
SET matrix_id = $3, matrix_room_id = $2
WHERE id = $1
`

type UpdateThreadMatrixIdsParams struct {
	ID           int64
	MatrixRoomID pgtype.Text
	MatrixID     pgtype.Text
}

func (q *Queries) UpdateThreadMatrixIds(ctx context.Context, arg UpdateThreadMatrixIdsParams) error {
	_, err := q.db.Exec(ctx, updateThreadMatrixIds, arg.ID, arg.MatrixRoomID, arg.MatrixID)
	return err
}
